* Staggered Field
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:
#+begin_src julia
  struct StaggeredField{Role}
      values::Matrix{Float64}
  end

  function StaggeredField(::Type{Role}, nx::Int, ny::Int) where {Role}
      values = Matrix{Float64}(undef, nx + 2, ny + 2)
      return StaggeredField{Role}(values)
  end

  function Base.getindex(field::StaggeredField, i::Int, j::Int)
      return field.values[i + 1, j + 1]
  end

  function Base.setindex!(field::StaggeredField, v::Float64, i::Int, j::Int)
      return (field.values[i + 1, j + 1] = v)
  end

  function Base.maximum(field::StaggeredField)
      A = field.values
      m = -Inf
      for j in 2:size(A,2)-1
          for i in 2:size(A,1)-1
              x = A[i,j]
              m = ifelse(x > m, x, m)
          end
      end
      return m
  end

  function maxabs(field::StaggeredField)
      A = field.values
      m = 0.0
      for j in 2:size(A,2)-1
          for i in 2:size(A,1)-1
              x = abs(A[i,j])
              m = ifelse(x > m, x, m)
          end
      end
      return m
  end

  function Base.show(io::IO, field::StaggeredField)
      return print(io, "$(typeof(field))")
  end

  function set!(field::StaggeredField, x::Float64)
      fill!(field.values, x)
      return field
  end
#+end_src

* Roles
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

Roles that the ~StaggeredField~ objects play.

#+begin_src julia
  struct U end  # x-direction velocity
  struct V end  # y-direction velocity
  struct P end  # pressure

  struct F end
  struct G end
  struct RHS end

  struct PRes end
#+end_src
* Boundary Value Applications
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

#+begin_src julia
    function set_n_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                     imax::Int, jmax::Int)
      # moving lid for U BC
      U_lid = 1.0
      for i in 1:imax
          u[i, jmax + 1] = 2 * U_lid - u[i, jmax]
          v[i, jmax] = 0.0
      end
  end

  function set_s_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                     imax::Int, ::Int)
      for i in 1:imax
          u[i, 0] = -u[i, 1]
          v[i, 0] = 0.0
      end
  end

  function set_e_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                     imax::Int, jmax::Int)
      for j in 1:jmax
          u[imax, j] = 0.0
          v[imax + 1, j] = -v[imax, j]
      end
  end

  function set_w_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                     ::Int, jmax::Int)
      for j in 1:jmax
          u[0, j] = 0.0
          v[0, j] = -v[1, j]
      end
  end

  function set_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                   imax::Int, jmax::Int)
      set_n_bv!(u, v, imax, jmax)
      set_s_bv!(u, v, imax, jmax)
      set_e_bv!(u, v, imax, jmax)
      set_w_bv!(u, v, imax, jmax)
      return
  end

#+end_src
* Operators
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

** Laplacian

\begin{equation*}
\left[\frac{\partial^2 f}{\partial x^2}\right]_{i,j} + \left[\frac{\partial^2 f}{\partial y^2}\right]_{i,j}
\end{equation*}

#+begin_src julia
  function lap(f::StaggeredField, δx::Float64, δy::Float64, i::Int, j::Int)
      ∂x² = (f[i + 1, j] - 2.0 * f[i, j] + f[i - 1, j]) / δx^2
      ∂y² = (f[i, j + 1] - 2.0 * f[i, j] + f[i, j - 1]) / δy^2
      return ∂x² + ∂y²
  end
#+end_src

** Divergence

\begin{equation*}
\frac{F^{(n)}_{i,j} - F^{(n)}_{i-1,j}}{\delta x} + \frac{G^{(n)}_{i,j} - G^{(n)}_{i,j-1}}{\delta y}
\end{equation*}
#+begin_src julia
  function div(f::StaggeredField{F}, g::StaggeredField{G},
               δx::Float64, δy::Float64, i::Int, j::Int)
      return (f[i, j] - f[i - 1, j]) / δx + (g[i, j] - g[i, j - 1]) / δy
  end
#+end_src

** Advection

*** Advection in the x-direction
**** Advection of u in x-direction
\begin{equation*}
\left[\frac{\partial(u^2)}{\partial x}\right]_{i,j}
\end{equation*}
#+begin_src julia
  function advect_x(u::StaggeredField{U}, u_adv::StaggeredField{U},
                    δx::Float64, γ::Float64, i::Int, j::Int)
      kr = (u_adv[i, j] + u_adv[i + 1, j]) / 2.0
      kl = (u_adv[i - 1, j] + u_adv[i, j]) / 2.0
      return 1.0 / δx * ((kr * (u[i, j] + u[i + 1, j]) / 2.0 -
                          kl * (u[i - 1, j] + u[i, j]) / 2.0) +
                         γ * (abs(kr) * (u[i, j] - u[i + 1, j]) / 2.0 -
                              abs(kl) * (u[i - 1, j] - u[i, j]) / 2.0))
  end
#+end_src

**** Advection of v in x-direction
\begin{equation*}
\left[\frac{\partial(uv)}{\partial x}\right]_{i,j}
\end{equation*}
#+begin_src julia
  function advect_x(v::StaggeredField{V}, u_adv::StaggeredField{U},
                    δx::Float64, γ::Float64, i::Int, j::Int)
      kr = (u_adv[i, j] + u_adv[i, j + 1]) / 2.0
      kl = (u_adv[i - 1, j] + u_adv[i - 1, j + 1]) / 2.0
      return 1.0 / δx * ((kr * (v[i, j] + v[i + 1, j]) / 2.0) -
                         kl * (v[i - 1, j] + v[i, j]) / 2.0 +
                         γ * (abs(kr) * (v[i, j] - v[i + 1, j]) / 2.0 -
                              abs(kl) * (v[i - 1, j] - v[i, j]) / 2.0))
  end

#+end_src

*** Advection in the y-direction
**** Advection of u in y-direction

\begin{equation*}
\left[\frac{\partial(uv)}{\partial y}\right]_{i,j}
\end{equation*}

#+begin_src julia
  function advect_y(u::StaggeredField{U}, v_adv::StaggeredField{V},
                    δy::Float64, γ::Float64, i::Int, j::Int)
      ku = (v_adv[i, j] + v_adv[i + 1, j]) / 2.0
      kd = (v_adv[i, j - 1] + v_adv[i + 1, j - 1]) / 2.0
      return 1.0 / δy * ((ku * (u[i, j] + u[i, j + 1]) / 2.0 -
                          kd * (u[i, j - 1] + u[i, j]) / 2.0) +
                         γ * (abs(ku) * (u[i, j] - u[i, j + 1]) / 2.0 -
                              abs(kd) * (u[i, j - 1] - u[i, j]) / 2.0))
  end
#+end_src
**** Advection of v in y-direction

\begin{equation*}
\left[\frac{\partial(v^2)}{\partial y}\right]_{i,j}
\end{equation*}

#+begin_src julia
  function advect_y(v::StaggeredField{V}, v_adv::StaggeredField{V},
                    δy::Float64, γ::Float64, i::Int, j::Int)
      ku = (v_adv[i, j] + v_adv[i, j + 1]) / 2.0
      kd = (v_adv[i, j - 1] + v_adv[i, j]) / 2.0
      return 1.0 / δy * ((ku * (v[i, j] + v[i, j + 1]) / 2.0 -
                          kd * (v[i, j - 1] + v[i, j]) / 2.0) +
                         γ * (abs(ku) * (v[i, j] - v[i, j + 1]) / 2.0 -
                              abs(kd) * (v[i, j - 1] - v[i, j]) / 2.0))
  end
#+end_src

*** Total advection of u

\begin{equation*}
\left[\frac{\partial(u^2)}{\partial x}\right]_{i,j} + \left[\frac{\partial(uv)}{\partial y}\right]_{i,j}
\end{equation*}

#+begin_src julia
  function advect_u(u::StaggeredField{U}, v::StaggeredField{V},
                    δx::Float64, δy::Float64, γ::Float64,
                    i::Int, j::Int)
      return advect_x(u, u, δx, γ, i, j) + advect_y(u, v, δy, γ, i, j)
  end
#+end_src

*** Total advection of v

\begin{equation*}
\left[\frac{\partial(uv)}{\partial x}\right]_{i,j} + \left[\frac{\partial(v^2)}{\partial y}\right]_{i,j}
\end{equation*}

#+begin_src julia
  function advect_v(u::StaggeredField{U}, v::StaggeredField{V},
                    δx::Float64, δy::Float64, γ::Float64,
                    i::Int, j::Int)
      return advect_x(v, u, δx, γ, i, j) + advect_y(v, v, δy, γ, i, j)
  end
#+end_src

* Time
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

\begin{equation*}
\delta t \coloneq \tau \min\left(\frac{Re}{2}\left(\frac{1}{\delta x^2} + \frac{1}{\delta y^2}\right)^{-1}, \frac{\delta x}{\lvert u_{\max}\rvert}, \frac{\delta y}{\lvert v_{\max}\rvert}\right)
\end{equation*}

#+begin_src julia
  function compute_δt(u::StaggeredField{U}, v::StaggeredField{V},
                      δx::Float64, δy::Float64,
                      Re::Float64, τ::Float64)
      return τ * min(Re / 2 * (1 / (δx*δx) + 1 / (δy*δy))^-1,
                     δx/maxabs(u),
                     δy/maxabs(v))
  end
#+end_src

* F and G
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

#+begin_src julia
  function compute_f(u::StaggeredField{U}, v::StaggeredField{V},
                     δx::Float64, δy::Float64, δt::Float64,
                     GX::Float64, Re::Float64, γ::Float64,
                     i::Int, j::Int)
      return u[i, j] +
             δt * (1.0 / Re * (lap(u, δx, δy, i, j)) -
                   advect_u(u, v, δx, δy, γ, i, j) + GX)
  end
#+end_src

#+begin_src julia
  function fill_f!(f::StaggeredField{F},
                   u::StaggeredField{U}, v::StaggeredField{V},
                   δx::Float64, δy::Float64, δt::Float64,
                   GX::Float64, Re::Float64, γ::Float64,
                   imax::Int, jmax::Int)
      for j in 1:jmax
          for i in 1:(imax - 1)
              f[i,j] = compute_f(u, v, δx, δy, δt, GX, Re, γ, i, j)
          end
      end
  end
#+end_src

#+begin_src julia
  function compute_g(u::StaggeredField{U}, v::StaggeredField{V},
                     δx::Float64, δy::Float64, δt::Float64,
                     GY::Float64, Re::Float64, γ::Float64,
                     i::Int, j::Int)
      return v[i, j] +
             δt * (1.0 / Re * (lap(v, δx, δy, i, j)) -
                   advect_v(u, v, δx, δy, γ, i, j) + GY)
  end
#+end_src

#+begin_src julia
  function fill_g!(g::StaggeredField{G},
                   u::StaggeredField{U}, v::StaggeredField{V},
                   δx::Float64, δy::Float64, δt::Float64,
                   GY::Float64, Re::Float64, γ::Float64,
                   imax::Int, jmax::Int)
      for j in 1:(jmax - 1)
          for i in 1:imax
              g[i,j] = compute_g(u, v, δx, δy, δt, GY, Re, γ, i, j)
          end
      end
  end
#+end_src

#+begin_src julia
  function set_bv!(u::StaggeredField{U}, v::StaggeredField{V},
                   f::StaggeredField{F}, g::StaggeredField{G},
                   imax::Int, jmax::Int)
      for i in 1:imax
          g[i, 0] = v[i, 0]
          g[i, jmax] = v[i, jmax]
      end
      for j in 1:jmax
          f[0, j] = u[0, j]
          f[imax, j] = u[imax, j]
      end
  end
#+end_src

* Right-hand Side of Pressure Equation
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

   \begin{equation*}
   rhs_{i,j} = \frac{1}{\delta t}\left(\frac{F^{(n)}_{i,j} - F^{(n)}_{i-1,j}}{\delta x} + \frac{G^{(n)}_{i,j} - G^{(n)}_{i,j-1}}{\delta y}\right)
   \end{equation*}

#+begin_src julia
  function compute_rhs(f::StaggeredField{F}, g::StaggeredField{G},
                       δx::Float64, δy::Float64, δt::Float64,
                       i::Int, j::Int)
      return 1.0/δt * ((f[i,j] - f[i-1,j])/δx + (g[i,j] - g[i,j-1])/δy)
  end
#+end_src

#+begin_src julia
  function fill_rhs!(rhs::StaggeredField{RHS},
                     f::StaggeredField{F}, g::StaggeredField{G},
                     δx::Float64, δy::Float64, δt::Float64,
                     imax::Int, jmax::Int)
      for j in 1:jmax
          for i in 1:imax
              rhs[i,j] = compute_rhs(f, g, δx, δy, δt, i, j)
          end
      end
  end

#+end_src

* Pressure
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

\begin{equation*}
p^{\mathrm{it}+1}_{i,j} \coloneqq (1 - \omega)p^{\mathrm{it}}_{i,j} + \frac{\omega}{\frac{2}{\delta x^2} + \frac{2}{\delta y^2}}\left(\frac{p^{\mathrm{it}}_{i+1,j} + p^{\mathrm{it}+1}_{i-1,j}}{\delta x^2} + \frac{p^{\mathrm{it}}_{i,j+1} + p^{\mathrm{it}+1}_{i,j-1}}{\delta y^2} - rhs_{i,j}\right)
\end{equation*}

#+begin_src julia
  function p_it(p::StaggeredField{P}, rhs::StaggeredField{RHS},
                δx::Float64, δy::Float64, ω::Float64,
                i::Int, j::Int)
      return (1.0 - ω)*p[i,j] +
          ω/(2.0/δx^2 + 2.0/δy^2)*
          ((p[i+1,j] + p[i-1,j])/δx^2 +
          (p[i,j+1] + p[i,j-1])/δy^2 - rhs[i,j])
  end
#+end_src

\begin{equation*}
r^{\mathrm{it}}_{i,j} \coloneqq \nabla^2 p^{\mathrm{it}} - rhs_{i,j}
\end{equation*}

#+begin_src julia
  function res(p_it::StaggeredField{P}, rhs::StaggeredField,
               δx::Float64, δy::Float64,
               i::Int, j::Int)
      return lap(p_it, δx, δy, i, j) - rhs[i,j]
  end
#+end_src

#+begin_src julia
  function set_bv!(p::StaggeredField{P}, imax::Int, jmax::Int)
      for i in 1:imax
          p[i, 0] = p[i, 1]
          p[i, jmax + 1] = p[i, jmax]
      end
      for j in 1:jmax
          p[0, j] = p[1, j]
          p[imax + 1, j] = p[imax, j]
      end
  end
#+end_src

#+begin_src julia
  function iter_pressure(p::StaggeredField{P}, rhs::StaggeredField{RHS},
                         p_res::StaggeredField{PRes},
                         δx::Float64, δy::Float64,
                         ω::Float64, ϵₚ::Float64,
                         iter_max::Int, imax::Int, jmax::Int)

      it = 0

      p_norm = maxabs(p)

      while it < iter_max

          for j in 1:jmax
              for i in 1:imax
                  p[i, j] = p_it(p, rhs, δx, δy, ω, i, j)
              end
          end

          for j in 1:jmax
              for i in 1:imax
                  p_res[i, j] = res(p, rhs, δx, δy, i, j)
              end
          end

          if maxabs(p_res) < ϵₚ * p_norm
              break
          end

          it = it + 1

          set_bv!(p, imax, jmax)
      end

      return it
  end
#+end_src

* Velocity
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

\begin{equation*}
u^{n+1}_{i,j} = F^{(n)}_{i,j} - \frac{\delta t}{\delta x}\left(p^{(n+1)}_{i+1,j} - p^{(n+1)}_{i,j}\right)
\end{equation*}

$i = 1,\dots,i_{\max}-1$, $j = 1,\dots,j_{\max}$

#+begin_src julia
  function comp_u_next(f::StaggeredField{F}, p::StaggeredField{P},
                  δx::Float64, δt::Float64,
                  i::Int, j::Int)
      return f[i,j] - δt/δx*(p[i+1,j] - p[i,j])
  end
#+end_src

#+begin_src julia
  function fill_u_next!(u_next::StaggeredField{U},
                        f::StaggeredField{F}, p::StaggeredField{P},
                        δx::Float64, δt::Float64,
                        imax::Int, jmax::Int)
      for j in 1:jmax
          for i in 1:(imax-1)
              u_next[i,j] = comp_u_next(f, p, δx, δt, i, j)
          end
      end
  end
#+end_src

  \begin{equation*}
  v^{n+1}_{i,j} = G^{(n)}_{i,j} - \frac{\delta t}{\delta y}\left(p^{(n+1)}_{i,j+1} - p^{(n+1)}_{i,j}\right)
  \end{equation*}

$i = 1,\dots,i_{\max}$, $j = 1,\dots,j_{\max} - 1$

#+begin_src julia
  function comp_v_next(g::StaggeredField{G}, p::StaggeredField{P},
                  δy::Float64, δt::Float64,
                  i::Int, j::Int)
      return g[i,j] - δt/δy*(p[i,j+1] - p[i,j])
  end
#+end_src

#+begin_src julia
    function fill_v_next!(v_next::StaggeredField{V},
                        g::StaggeredField{G}, p::StaggeredField{P},
                        δy::Float64, δt::Float64,
                        imax::Int, jmax::Int)
      for j in 1:(jmax-1)
          for i in 1:imax
              v_next[i,j] = comp_v_next(g, p, δy, δt, i, j)
          end
      end
  end
#+end_src

* Interpolate
:PROPERTIES:
:header-args:julia: :results none :tangle "nsfd.jl"
:END:

#+begin_src julia
  function interpolate(u::StaggeredField{U},
                       δx::Float64, δy::Float64,
                       x::Float64, y::Float64)
      i = Int(floor(x / δx)) + 1
      j = Int(floor((y + δy / 2) / δy)) + 1
      x₁ = (i - 1.0) * δx
      x₂ = i * δx
      y₁ = ((j - 1.0) - 0.5) * δy
      y₂ = (j - 0.5) * δy
      u₁ = u[i - 1, j - 1]
      u₂ = u[i, j - 1]
      u₃ = u[i - 1, j]
      u₄ = u[i, j]
      return 1 / (δx * δy) *
             ((x₂ - x) * (y₂ - y) * u₁ +
              (x - x₁) * (y₂ - y) * u₂ +
              (x₂ - x) * (y - y₁) * u₃ +
              (x - x₁) * (y - y₁) * u₄)
  end
#+end_src

#+begin_src julia
  function interpolate(v::StaggeredField{V},
                       δx::Float64, δy::Float64,
                       x::Float64, y::Float64)
      i = Int(floor((x + δx / 2) / δx)) + 1
      j = Int(floor(y / δy)) + 1
      x₁ = ((i - 1) - 0.5)δx
      x₂ = (i - 0.5) * δx
      y₁ = (j - 1) * δy
      y₂ = j * δy
      v₁ = v[i - 1, j - 1]
      v₂ = v[i, j - 1]
      v₃ = v[i - 1, j]
      v₄ = v[i, j]
      return 1 / (δx * δy) *
             ((x₂ - x) * (y₂ - y) * v₁ +
              (x - x₁) * (y₂ - y) * v₂ +
              (x₂ - x) * (y - y₁) * v₃ +
              (x - x₁) * (y - y₁) * v₄)
  end
#+end_src

#+begin_src julia
  function interpolate(p::StaggeredField{P},
                       δx::Float64, δy::Float64,
                       x::Float64, y::Float64)
      i = Int(floor((x + δx / 2.0) / δx)) + 1
      j = Int(floor((y + δy / 2.0) / δy)) + 1
      x₁ = (i - 1) * δx
      x₂ = i * δx
      y₁ = (j - 1) * δy
      y₂ = j * δy
      p₁ = p[i - 1, j - 1]
      p₂ = p[i, j - 1]
      p₃ = p[i - 1, j]
      p₄ = p[i, j]
      return 1 / (δx * δy) *
             ((x₂ - x) * (y₂ - y)p₁ +
              (x - x₁) * (y₂ - y)p₂ +
              (x₂ - x) * (y - y₁)p₃ +
              (x - x₁) * (y - y₁)p₄)
  end
#+end_src
